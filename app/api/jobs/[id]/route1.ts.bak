// app/api/jobs/[id]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { getSessionOrThrow, getSessionCompanyId } from "@/lib/session";
import { EmploymentType, JobStatus } from "@prisma/client";

/**
 * GET /api/jobs/[id]
 * Devuelve una vacante específica (solo si pertenece a la empresa del recruiter)
 */
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    await getSessionOrThrow();
    const companyId = await getSessionCompanyId();

    const job = await prisma.job.findFirst({
      where: { id: params.id, companyId },
      select: {
        id: true,
        title: true,
        description: true,

        // Ubicación
        location: true,
        remote: true,
        country: true,
        admin1: true,
        city: true,
        cityNorm: true,
        admin1Norm: true,
        locationLat: true,
        locationLng: true,

        // Tipo / horario / visibilidad de sueldo
        employmentType: true,
        schedule: true,
        showSalary: true,

        // Sueldo
        salaryMin: true,
        salaryMax: true,
        currency: true,

        // Skills legacy + nuevas estructuras
        skills: true,
        skillsJson: true,
        certsJson: true,

        // Educación
        educationJson: true,
        minDegree: true,

        // Prestaciones (opcional)
        benefitsJson: true,

        status: true,
        createdAt: true,
        updatedAt: true,
      },
    });

    if (!job) {
      return NextResponse.json({ error: "Vacante no encontrada" }, { status: 404 });
    }

    return NextResponse.json(job);
  } catch (err) {
    console.error("[GET /api/jobs/[id]]", err);
    return NextResponse.json({ error: "Error al obtener la vacante" }, { status: 500 });
  }
}

/**
 * PATCH /api/jobs/[id]
 * Actualiza una vacante (usado por JobWizard en modo edición)
 *
 * Acepta FormData con:
 * - title, description, employmentType, currency, schedule?, showSalary?
 * - locationType (REMOTE | HYBRID | ONSITE), city
 * - country?, admin1?, cityNorm?, admin1Norm?, locationLat?, locationLng?
 * - salaryMin?, salaryMax?
 * - skillsJson (Array<{name,required}>), certsJson (string[])
 * - educationJson (Array<{name,required}>), minDegree?
 * - benefitsJson (obj)
 */
export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getSessionOrThrow();
    const companyId = await getSessionCompanyId();

    // @ts-ignore
    const role = session.user?.role as "RECRUITER" | "ADMIN" | string | undefined;
    if (role !== "RECRUITER" && role !== "ADMIN") {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    const formData = await req.formData();
    const get = (k: string) => formData.get(k)?.toString().trim() || "";

    // Obligatorios
    const title = get("title");
    const description = get("description");
    if (!title || !description) {
      return NextResponse.json({ error: "Faltan campos obligatorios" }, { status: 400 });
    }

    // Tipo / modalidad
    const employmentType = get("employmentType") as EmploymentType | "";
    const locationType = get("locationType"); // REMOTE | HYBRID | ONSITE
    const remote = locationType === "REMOTE";
    const city = get("city");

    // Ubicación extendida (opcionales)
    const country = get("country") || null;
    const admin1 = get("admin1") || null;
    const cityNorm = get("cityNorm") || null;
    const admin1Norm = get("admin1Norm") || null;

    const locationLatRaw = get("locationLat");
    const locationLngRaw = get("locationLng");
    const locationLat = locationLatRaw ? Number(locationLatRaw) : null;
    const locationLng = locationLngRaw ? Number(locationLngRaw) : null;

    // Sueldo / otros
    const currency = get("currency") || "MXN";
    const schedule = get("schedule") || null;
    const showSalary = get("showSalary") ? get("showSalary") === "true" : null;

    const salaryMin = formData.get("salaryMin") !== null ? Number(formData.get("salaryMin")) : null;
    const salaryMax = formData.get("salaryMax") !== null ? Number(formData.get("salaryMax")) : null;

    // JSONs
    let skillsJson: Array<{ name: string; required: boolean }> = [];
    let certsJson: string[] = [];
    let educationJson: Array<{ name: string; required: boolean }> = [];
    let benefitsJson: Record<string, any> | null = null;

    try {
      const raw = formData.get("skillsJson") as string | null;
      if (raw) skillsJson = JSON.parse(raw);
    } catch {}

    try {
      const raw = formData.get("certsJson") as string | null;
      if (raw) certsJson = JSON.parse(raw);
    } catch {}

    try {
      const raw = formData.get("educationJson") as string | null;
      if (raw) educationJson = JSON.parse(raw);
    } catch {}

    try {
      const raw = formData.get("benefitsJson") as string | null;
      if (raw) benefitsJson = JSON.parse(raw);
    } catch {}

    const minDegree = get("minDegree") || null;

    // Campo legacy "skills" (array de strings) derivado de skillsJson
    const legacySkills =
      Array.isArray(skillsJson) && skillsJson.length
        ? skillsJson.map((s) => `${s.required ? "Req" : "Dese"}: ${s.name}`)
        : [];

    // Armado de payload de actualización
    const data: any = {
      title,
      description,

      // Ubicación
      location: remote ? "Remoto" : city || "—",
      remote,
      country,
      admin1,
      city: city || null,
      cityNorm,
      admin1Norm,
      locationLat: Number.isFinite(locationLat as number) ? (locationLat as number) : null,
      locationLng: Number.isFinite(locationLng as number) ? (locationLng as number) : null,

      // Tipo / horario / visibilidad sueldo
      employmentType: employmentType || undefined,
      schedule,
      showSalary,

      // Sueldo
      salaryMin: salaryMin ?? null,
      salaryMax: salaryMax ?? null,
      currency,

      // Estructuras nuevas
      skillsJson,
      certsJson,
      educationJson,
      minDegree,
      benefitsJson,

      // Compatibilidad
      skills: legacySkills,

      updatedAt: new Date(),
    };

    // Limpieza: si algún campo vino explícitamente vacío, dejarlo en null
    if (!schedule) data.schedule = null;
    if (showSalary === null) delete data.showSalary; // no tocar si no vino
    if (!minDegree) data.minDegree = null;
    if (!educationJson?.length) data.educationJson = [];
    if (!skillsJson?.length) data.skillsJson = [];
    if (!certsJson?.length) data.certsJson = [];
    if (!benefitsJson || Object.keys(benefitsJson).length === 0) data.benefitsJson = null;

    // Seguridad multiempresa
    const updated = await prisma.job.updateMany({
      where: { id: params.id, companyId },
      data,
    });

    if (updated.count === 0) {
      return NextResponse.json(
        { error: "Vacante no encontrada o sin permisos" },
        { status: 404 }
      );
    }

    return NextResponse.json({ ok: true });
  } catch (err) {
    console.error("[PATCH /api/jobs/[id]]", err);
    return NextResponse.json({ error: "Error al actualizar la vacante" }, { status: 500 });
  }
}
